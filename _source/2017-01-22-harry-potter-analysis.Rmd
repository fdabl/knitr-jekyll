---
layout: post
title: "The Science behind the Magic: New paper on Harry Potter"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Introduction & Preparation
We read the data in.
```{r}
library('psych')
library('broom')
library('papaja')
library('stringr')
library('reshape2')
library('magrittr')
library('tidyverse')
theme_set(theme_apa())

dat <- read.csv('harry.csv', sep = ';')
describe(select(dat, -starts_with('PVQ')), skew = FALSE)
```

Let's sum up the individual questionnaire data to single scores, after removing people younger than 18 or older than 100.

```{r}
recode <- function(house, sorted) as.factor(as.numeric(house == sorted))
sum_over <- function(score, dat) rowSums(select(dat, one_of(paste0('PVQ_', score))))

SELF_SCORE <- c('01', '23', '39', '16', '30', '23')
STIM_SCORE <- c('10', '28', '43')
HEDON_SCORE <- c('03', '36', '46')
ACHIEVEMENT_SCORE <- c('17', '32', '48')
POWER_SCORE <- c('06', '29', '41', '12', '20', '44')
SECUR_SCORE <- c('13', '26', '53', '02', '35', '50')
CONFOR_SCORE <- c('15', '31', '42', '04', '22', '51')
TRADIT_SCORE <- c('18', '33', '40', '07', '38', '54')
BENEV_SCORE <- c('11', '25', '47', '19', '27', '55')
UNIV_SCORE <- c('08', '21', '45', '05', '37', '52', '14', '34', '57')

dat <- dat %>% 
  filter(age >= 18 & age <= 100) %>% 
  mutate(
    match = Sorting_house == Sorting_house_wish,
    Gryffindor = recode('Gryffindor', Sorting_house),
    Hufflepuff = recode('Hufflepuff', Sorting_house),
    Ravenclar  = recode('Ravenclaw', Sorting_house),
    Slytherin  = recode('Slytherin', Sorting_house),
    
    self = sum_over(SELF_SCORE, .),
    stim = sum_over(STIM_SCORE, .),
    hedon = sum_over(HEDON_SCORE, .),
    achievement = sum_over(ACHIEVEMENT_SCORE, .),
    power = sum_over(POWER_SCORE, .),
    secur = sum_over(SECUR_SCORE, .),
    confor = sum_over(CONFOR_SCORE, .),
    tradit = sum_over(TRADIT_SCORE, .),
    benev = sum_over(BENEV_SCORE, .),
    univ = sum_over(UNIV_SCORE, .)
  ) %>% 
  rename(ach = achievement) %>% 
  select(-starts_with('PVQ_'))

describe(select(dat, self:univ), skew = FALSE)
```

## Hypotheses
Our hypotheses are as follows

- **Gryffindor** should be higher on **Extraversion** than the other houses
- **Ravenclaw** should be higher on **Intellect** than the other houses
- **Hufflepuff** should be higher on **Agreeableness and Conscientiousness** than the other houses
- **Slytherin** should be higher on **Machiavellianism, Narcissism, and Psychopathy** than the other houses

For the human value data, we do not have clear hypotheses but will still look at the data in an exploratory fashion. Our analysis plan is as follows.

But first, let's take a look at the data.

# Data visualisation
## IPIP Scores
Let's first take a look at the IPIP questionnaire data across the houses.
```{r, echo = FALSE}
make_mean_df <- function(columns) {
  dat %>% 
    select(Sorting_house, columns) %>% 
    group_by(Sorting_house) %>% 
    summarize_each(funs(mean)) %>% 
    melt
}

plot_mean_df <- function(df, title) {
  ggplot(df, aes(x = variable, y = value, color = Sorting_house)) +
    geom_point() +
    geom_line(aes(group = Sorting_house)) +
    ylab('Value') +
    xlab('Big 5') +
    ylim(c(25, 45)) +
    ggtitle(title) +
    theme(axis.title = element_text(size = 20),
          plot.title = element_text(size = 18, face = 'bold', hjust = .5),
          legend.title = element_text(size = 16),
          axis.text = element_text(size = 10),
          axis.text.x = element_text(angle = 12)) +
    scale_color_discrete(name = 'House') +
    scale_y_continuous(breaks = pretty(df$value))
}

IPIP_dat <- make_mean_df(starts_with('IPI')) %>% 
  mutate(variable = str_replace(as.character(variable), 'IPIP_', ''))
plot_mean_df(IPIP_dat, 'Mean IPIP Scores across Houses')
```

Above we see that there are no big differences between the houses in general. However, on 'Agreeableness', Slytherin is reduced, while Hufflepuff has an increased value. Additionally, it seems that Gryffindor has higher extraversion than the other ones.

However, it's always good to plot more than just the mean (dough!).
```{r, echo = FALSE}
IPIP_full <- select(dat, Sorting_house, starts_with('IPIP')) %>% 
  melt %>% 
  mutate(variable = str_replace(as.character(variable), 'IPIP_', ''))

plot_full_df <- function(df, title) {
  ggplot(df, aes(x = variable, y = value)) +
    geom_boxplot(aes(fill = Sorting_house)) +
    ylab('Value') +
    xlab('Variable') +
    ggtitle(title) +
    theme(plot.title = element_text(size = 18, face = 'bold', hjust = .5),
          axis.title = element_text(size = 20),
          legend.title = element_text(size = 16),
          axis.text = element_text(size = 10),
          axis.text.x = element_text(angle = 12)) +
    scale_fill_discrete(name = 'House')
}

plot_full_df(IPIP_full, 'Boxplots for the Big 5')
```

## Dark Triad
Let's look at the Dark Triad. Here the differences seem much more pronounced.

```{r}
SD_dat <- make_mean_df(starts_with('SD')) %>% 
  mutate(variable = str_replace(as.character(variable), 'SD3_', ''))
plot_mean_df(SD_dat, 'Mean Dark Triad across Houses')
```

This is beautiful! It seems that Slytherin scores highest on all aspects of the Dark Triad, while Hufflepuff scores lowest. Exactly as one would expect.

```{r}
SD_full <- select(dat, Sorting_house, starts_with('SD3')) %>% 
  melt %>% 
  mutate(variable = str_replace(as.character(variable), 'SD3_', ''))

plot_full_df(SD_full, 'Dark Triad across Houses')
```


## Human Values
Exploratory stuff, and not much to see here except that Slytherin is higher on power and lower on conformity.

```{r}
human_values <- make_mean_df(34:43)
plot_mean_df(human_values, 'Human values across Houses')
```

```{r}
human_values_full <- select(dat, Sorting_house, self:univ) %>%  melt
plot_full_df(human_values_full, 'Human values across houses')
```

```{r}
library('mgm')
library('qgraph')

dat_val <- select(dat, self:univ)

fit_graph <- function(dat, house) {
  lev <- rep(1, 10)
  type <- rep('g', 10)
  dat_val <- dat %>% 
    filter(Sorting_house == house) %>% 
    select(self:univ)
  
  mgmfit(dat_val, type = type, lev = lev, lambda.sel = 'EBIC', d = 2)
}

plot_graph <- function(fit, dat, title) {
  groups_type <- as.list(setNames(1:10, names(dat)))
  
  qgraph(
    fit$adj, 
    vsize = 6, 
    esize = 4,
    layout = "spring",
    edge.labels = round(fit$wadj, 2),
    edge.color = rgb(33, 33, 33, 100, maxColorValue = 255), 
    border.width = 1.5,
    border.color = "black",
    groups = groups_type,
    title = title,
    labels = names(groups_type),
    legend = FALSE
    )
}
```

```{r}
fit_g <- fit_graph(dat, 'Gryffindor')
fit_s <- fit_graph(dat, 'Slytherin')
fit_h <- fit_graph(dat, 'Hufflepuff')
fit_r <- fit_graph(dat, 'Ravenclaw')
```

```{r, echo = FALSE}
plot_graph(fit_g, dat_val, 'Network of Human values for Gryffindor')
plot_graph(fit_s, dat_val, 'Network of Human values for Slytherin')
plot_graph(fit_h, dat_val, 'Network of Human values for Hufflepuff')
plot_graph(fit_r, dat_val,'Network of Human values for Ravenclaw')
```


# Data Analysis
## Bayesian analysis
Here I distinguish between *model comparison*, and *parameter estimation*. ROPE butchers the distinction because it thinks it can use parameter estimation to do model comparison.

Our hypothesis is that Slytherin has a higher machiavellianism score than the average of the other three houses. Therefore, we see how often the mean of Slytherin is higher than the mean of the other three houses (we can, of course, test more interesting hypotheses). For more, see [here](http://bayesfactor.blogspot.co.at/2015/01/multiple-comparisons-with-bayesfactor-2.html).

The Bayes factor is

$$
\begin{align*}
\text{posterior odds} =& \text{prior odds} \times \text{Bayes factor} \\
\text{Bayes factor} =& \frac{\text{posterior odds}}{\text{prior odds}}
\end{align*}
$$

We want to test our order restricted hypothesis against the null hypothesis. Luckily, the Bayes factor is transitive, such that

$$
\begin{align*}
\frac{p(\textbf{y}|M_r)}{p(\textbf{y}|M_0)} = \frac{p(\textbf{y}|M_r)}{p(\textbf{y}|M_f)} \cdot \frac{p(\textbf{y}|M_f)}{p(\textbf{y}|M_0)} 
\end{align*}
$$

where $M_r$ denotes the restricted model in which $\text{Slytherin} > \text{Mean(Gryffindor, Hufflepuff, Ravenclar)}$, $M_0$ denotes the null model in which $\text{Gryffindor} = \text{Slytherin} = \text{Hufflepuff} = \text{Ravenclaw}$, and the full model has a parameter for each mean, such that they can vary independently without constraint. So we can compute the Bayes factor we are interested in as follows.

Woho! Huge Bayes factor that the means are different. Well, that's rather obvious and not of interest, though.
```{r}
library('BayesFactor')

(bf_full_zero <- anovaBF(SD3_Machiavellianism ~ Sorting_house, data = dat))
```

Now let's estimate the posterior means and variance (we do not model heteroscedasticity; seems there is none anyway). This is is sum-to-zero coded.
```{r}
post <- posterior(bf_full_zero, iterations = 10000)
head(post)
```

```{r}
main_house <- 'Slytherin'
other_houses <- c('Gryffindor', 'Hufflepuff', 'Ravenclaw')

# for the simple Helmert contrast
bayes_factor_restr_zero <- function(bf_full_zero, main_house, other_houses, iterations = 100000) {
  
  post <- posterior(bf_full_zero, iterations = iterations)
  mu <- post[, 1]
  header <- colnames(post)
  
  # compute the mean of the house we want to test the others against
  main <- mu + post[, grepl(main_house, header)]
  
  # compute the mean of the other three houses
  other <- sapply(other_houses, function(c) {
    mu + post[, grepl(c, header)]
    }) %>% rowMeans
  
  prior_odds <- 1/2
  posterior_odds <- mean(main > other) / nrow(post)
  
  bf_restr_full <- posterior_odds / prior_odds
  bf_restr_zero <- bf_restr_full * extractBF(bf_full_zero)$bf
  
  log(bf_restr_zero)
}

bayes_factor_restr_zero(bf_full_zero, main_house, other_houses)
```

However, using this method, we can test more interesting constraints. For example, we might be interested in orderings, say

$$
H_1: Gryffindor > Slytherin, Hufflepuff, Ravenclaw
$$

# Appendix
## Frequentist Analysis
The authors used the following Helmert contrast for their linear models.

```{r}
helmert <- matrix(c(3/4, -1/4, -1/4, -1/4, 0, 2/3, -1/3, -1/3, 0, 0, 1/2, -1/2), ncol = 3)
helmert
```

As an example, let's run a model
```{r}
m <- lm(dat$IPIP_Intellect ~ Sorting_house, data = dat)
tidy(m)
```

Therefore, the effects denote:

- **Sorting_house1**: Gryffindor against Hufflepuff + Ravenclaw + Slytherin
- **Sorting_house2**: Hufflepuff against Ravenclaw + Slytherin
- **Sorting_house3**: Ravenclaw against Slytherin

However, for the *Intellect* response, this is not what we want, since we want to compare Ravenclaw against all others.
```{r}
dat <- mutate(dat, Sorting_house = relevel(Sorting_house, ref = 'Ravenclaw'))
mclaw <- lm(dat$IPIP_Intellect ~ Sorting_house, data = dat)
tidy(mclaw)
```

```{r, echo = FALSE, eval = FALSE}
# Run all the linear models -- this does not take into account the
depvars <- select(dat, contains('IPIP'), contains('SD3'), self:univ) %>% names

models_freq <- lapply(depvars, function(depvar) {
  y <- dat[[depvar]]
  lm(y ~ Sorting_house, data = dat)
})
```
